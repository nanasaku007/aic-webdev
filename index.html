<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AIエージェント入門</title>
  <script>
    (() => {
      const stored = localStorage.getItem("theme");
      const theme =
        stored === "light" || stored === "dark"
          ? stored
          : matchMedia("(prefers-color-scheme: dark)").matches
            ? "dark"
            : "light";
      document.documentElement.dataset.theme = theme;
    })();
  </script>
  <link rel="stylesheet" href="styles.css?v=2">
</head>
<body>
  <div class="ripple-dots ripple-dots--bg" data-ripple-dots>
    <canvas class="ripple-dots__canvas" aria-hidden="true"></canvas>
  </div>
  <header class="site-header">
    <div class="container site-header__inner">
      <a class="brand" href="#top" aria-label="トップへ">
        <span class="brand-mark" aria-hidden="true"></span>
        <span>AIエージェント入門</span>
      </a>
      <nav class="nav" aria-label="ページ内ナビゲーション">
        <a href="#experience">体験</a>
        <a href="#architecture">アーキテクチャ</a>
        <a href="#tools">実装</a>
        <a href="#definition">位置づけ</a>
        <a href="use-cases.html">活用例</a>
        <a href="checklist.html">チェックリスト</a>
      </nav>
      <div class="theme-switch" role="group" aria-label="表示切り替え">
        <button type="button" class="theme-switch__button" data-ripple-toggle aria-label="波紋表示の切り替え" title="波紋表示">
          <svg class="theme-switch__icon" width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12Zm0 2a8 8 0 1 0 0-16a8 8 0 0 0 0 16Z"/>
          </svg>
        </button>
        <button type="button" class="theme-switch__button" data-theme-value="light" aria-label="ライトモード" title="ライトモード">
          <svg class="theme-switch__icon" width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M12 18a6 6 0 1 1 0-12a6 6 0 0 1 0 12Zm0-14a1 1 0 0 1-1-1V2a1 1 0 1 1 2 0v1a1 1 0 0 1-1 1Zm0 19a1 1 0 0 1-1-1v-1a1 1 0 1 1 2 0v1a1 1 0 0 1-1 1ZM4 13H3a1 1 0 1 1 0-2h1a1 1 0 1 1 0 2Zm19 0h-1a1 1 0 1 1 0-2h1a1 1 0 1 1 0 2ZM6.22 6.22a1 1 0 0 1-1.41 0l-.71-.71a1 1 0 0 1 1.41-1.41l.71.71a1 1 0 0 1 0 1.41Zm13.68 13.68a1 1 0 0 1-1.41 0l-.71-.71a1 1 0 0 1 1.41-1.41l.71.71a1 1 0 0 1 0 1.41ZM17.78 6.22a1 1 0 0 1 0-1.41l.71-.71a1 1 0 1 1 1.41 1.41l-.71.71a1 1 0 0 1-1.41 0ZM4.32 19.9a1 1 0 0 1 0-1.41l.71-.71a1 1 0 1 1 1.41 1.41l-.71.71a1 1 0 0 1-1.41 0Z"/>
          </svg>
        </button>
        <button type="button" class="theme-switch__button" data-theme-value="dark" aria-label="ナイトモード" title="ナイトモード">
          <svg class="theme-switch__icon" width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path fill="currentColor" d="M21 14.6A8.5 8.5 0 0 1 9.4 3a7.5 7.5 0 1 0 11.6 11.6Z"/>
          </svg>
        </button>
      </div>
    </div>
  </header>

  <div class="page">
    <aside class="side-banner" aria-label="セクションへ移動">
      <a href="#top">Top</a>
      <a href="#experience">体験</a>
      <a href="#architecture">設計</a>
      <a href="#tools">実装</a>
      <a href="#definition">定義</a>
      <a href="use-cases.html">活用例</a>
      <a href="checklist.html">チェック</a>
    </aside>

    <main id="top" class="main">
	    <section class="hero">
	      <div class="container hero-grid">
	        <div>
	          <h1>AIエージェントを、体験から理解する。</h1>
	          <p class="lead">チャットからCLI、そして「情報収集→推論→実行」へ。ユーザー体験とアーキテクチャの両面から、要点をコンパクトに整理します。</p>
	          <div class="actions">
	            <a class="button button--primary" href="#experience">読み始める</a>
            <a class="button button--secondary" href="#tools">実装観点を見る</a>
          </div>
        </div>

        <aside class="panel" aria-label="図解">
          <div class="panel__media">
            <img src="agent-cli.png" alt="AIエージェントのコマンドラインインターフェース" />
          </div>
          <div class="panel__caption">チャットでもCLIでも、AIエージェントによるやり取りは進化しています。</div>
        </aside>
      </div>
    </section>

    <section id="experience" class="section">
      <div class="container">
        <h2>ユーザーからみたAIエージェント体験</h2>
        <p>チャットボットとしてのAIエージェントには、ある「ビフォー／アフター」があります。</p>
	        <div class="grid-2" role="list">
		          <div class="card" role="listitem">
		            <div class="card__media">
		              <img class="card__img" src="illustration-before.png" alt="従来のチャットボットのイメージ" loading="lazy" />
		            </div>
	            <h3>Before：従来のチャットボット</h3>
	            <ul>
	              <li>ルールベースや単純なスロットフィリングが中心。</li>
	              <li>文脈を維持せず、同じ質問を何度も聞かれる。</li>
	              <li>対話が一方的で、ユーザーの意図に対する踏み込みが浅い。</li>
	            </ul>
	          </div>
		          <div class="card" role="listitem">
		            <div class="card__media">
		              <img class="card__img" src="illustration-after.png" alt="AIエージェントのイメージ" loading="lazy" />
		            </div>
	            <h3>After：今のAIエージェント</h3>
	            <ul>
	              <li>CodexやClaudeCodeのようなモデルがコードやドキュメントを理解して応答。</li>
	              <li>文脈を把握したマルチターン対話と、必要な補足情報の提案。</li>
              <li>ユーザーの役割を理解し、具体的なアクションに結びつける対話。</li>
            </ul>
          </div>
        </div>
        <p>AIエージェントは、単なる問い合わせ窓口ではなく「意図を達成するためのパートナー」になろうとしています。</p>
      </div>
    </section>

    <section id="architecture" class="section">
      <div class="container">
        <h2>MCP＆A2Aを支える仕組みとアーキテクチャ</h2>
        <p>MCP（Multi-Channel Platform）ツールは、複数のインターフェースを横断してユーザーとモデルをつなぎます。CLI、Web、APIなどのチャンネルに共通のコンテキストやステート管理を提供することで、ユーザー体験の一貫性を確保しています。</p>
        <p>A2A（Agent to Agent）通信は、専門特化型エージェント同士が役割分担して連携する仕組みです。たとえば、ドキュメント理解担当のエージェントがKnowledge Baseを検索し、アクション担当エージェントが結果をもとに外部APIを呼ぶといった構成になります。MCPはこうしたエージェント間のメッセージバスや認証・ロギングも担い、全体の信頼性を高めます。</p>
        <p>これらの層を通じて、ユーザーとの対話は単なる質問応答から「情報収集→推論→実行」へと進化します。</p>
      </div>
    </section>

    <section id="tools" class="section">
      <div class="container">
        <h2>エンジニア向け：実装手段とライブラリ</h2>
        <p>エージェントを実装する際には、生成AIのバックエンドからオーケストレーションまでを扱うプラットフォームやライブラリが役立ちます。</p>
        <ul class="list">
          <li><strong>AWS Bedrock AgentCore</strong>：プロンプトテンプレート、APIの安全なラッパー、ワークフロー定義などを含む、プロダクション対応のエージェントランタイム。</li>
          <li><strong>Langgraph</strong>：LLMの出力をステップ化し、副作用を制御しながらノードベースで組み合わせられるフロー型のオーケストレーションライブラリ。</li>
          <li><strong>AgentSDK</strong>：各種モデルプロバイダに対する共通インターフェースと、対話履歴やツール連携のパターンを提供する開発キット。</li>
        </ul>
        <p>これらのコンポーネントをMCPやA2Aアーキテクチャに組み込むことで、ユーザーから見た「頼れるエージェント」を整備できます。</p>
      </div>
    </section>

    <section id="definition" class="section">
      <div class="container">
        <h2>「AIエージェント」の位置づけ</h2>
        <p>「AIエージェント」は文脈によって意味合いが変わるため、自分の中で整理しておくと議論や開発がしやすくなります。以下の観点で分類してみました。</p>
        <ul class="list">
          <li><strong>会話型エージェント</strong>：ユーザーとの対話やコミュニケーションが主目的。質問応答、相談、チーム内でのサポートなどによく使われます。</li>
          <li><strong>アクション型エージェント</strong>：目的達成のためにWeb操作やファイル操作などのアクションを自律的に実行するタイプです。</li>
          <li><strong>観測・分析型エージェント</strong>：センサーデータやログを観測し、異常検知や洞察・推論のレポートを行う構成です。</li>
          <li><strong>マルチモーダル・ロボティクス系</strong>：視覚・音声・物理世界への介入を組み合わせ、環境との複雑なやり取りを行うエージェントです。</li>
        </ul>
        <p>多くのプロジェクトでは、上記の要素が組み合わさっており、用途や期待される体験に応じて設計のバランスをとる必要があります。</p>
      </div>
    </section>
	  </main>
  </div>

  <footer class="site-footer">
    <div class="container">
      <span>© nanasaku007</span>
    </div>
  </footer>
  <script>
    (() => {
      const root = document.documentElement;
      const buttons = Array.from(document.querySelectorAll("[data-theme-value]"));

      const apply = (theme) => {
        root.dataset.theme = theme;
        localStorage.setItem("theme", theme);
        for (const button of buttons) {
          button.setAttribute("aria-pressed", String(button.dataset.themeValue === theme));
        }
      };

      const current = root.dataset.theme === "dark" ? "dark" : "light";
      apply(current);

      for (const button of buttons) {
        button.addEventListener("click", () => apply(button.dataset.themeValue));
      }
    })();
  </script>
  <script>
    (() => {
      const mount = document.querySelector("[data-ripple-dots]");
      if (!mount) return;

      const canvas = mount.querySelector("canvas");
      const ctx = canvas.getContext("2d", { alpha: true });
      if (!ctx) return;

      const rippleToggle = document.querySelector("[data-ripple-toggle]");

      const state = {
        dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
        width: 0,
        height: 0,
        rafId: 0,
        pointerX: 0,
        pointerY: 0,
        lastMoveAt: performance.now(),
        hasPointer: false,
        points: [],
        enabled: true,
      };

      const config = {
        spacing: 16,
        radius: 1.2,
        amplitude: 12,
        decay: 140,
        waveFreq: 0.12,
        waveSpeed: 0.020,
        idleFadeMs: 1400,
      };

      const resize = () => {
        const rect = mount.getBoundingClientRect();
        const width = Math.max(1, Math.floor(rect.width));
        const height = Math.max(1, Math.floor(rect.height));
        state.width = width;
        state.height = height;

        canvas.width = Math.floor(width * state.dpr);
        canvas.height = Math.floor(height * state.dpr);
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);

        const pad = Math.round(config.spacing * 0.5);
        const points = [];
        for (let y = pad; y <= height - pad; y += config.spacing) {
          for (let x = pad; x <= width - pad; x += config.spacing) {
            points.push({ x, y });
          }
        }
        state.points = points;
      };

      const onPointerMove = (event) => {
        const rect = mount.getBoundingClientRect();
        state.pointerX = event.clientX - rect.left;
        state.pointerY = event.clientY - rect.top;
        state.lastMoveAt = performance.now();
        state.hasPointer = true;
      };

      const draw = (now) => {
        if (!state.enabled) {
          state.rafId = 0;
          return;
        }
        ctx.clearRect(0, 0, state.width, state.height);

        const theme = document.documentElement.dataset.theme === "dark" ? "dark" : "light";
        const dot = theme === "dark" ? "rgba(255, 255, 255, 0.10)" : "rgba(15, 23, 42, 0.08)";

        const elapsed = now - state.lastMoveAt;
        const idle = Math.min(1, elapsed / config.idleFadeMs);
        const activity = state.hasPointer ? 1 : 1 - idle;

        ctx.fillStyle = dot;
        for (const p of state.points) {
          let x = p.x;
          let y = p.y;

          if (activity > 0.001) {
            const dx = x - state.pointerX;
            const dy = y - state.pointerY;
            const dist = Math.hypot(dx, dy) || 0.0001;

            const envelope = Math.exp(-dist / config.decay) * activity;
            const phase = dist * config.waveFreq - now * config.waveSpeed;
            const offset = Math.sin(phase) * config.amplitude * envelope;

            x += (dx / dist) * offset;
            y += (dy / dist) * offset;
          }

          ctx.beginPath();
          ctx.arc(x, y, config.radius, 0, Math.PI * 2);
          ctx.fill();
        }

        state.rafId = requestAnimationFrame(draw);
      };

      const applyEnabled = (enabled) => {
        state.enabled = enabled;
        mount.style.display = enabled ? "" : "none";
        if (rippleToggle) rippleToggle.setAttribute("aria-pressed", String(enabled));
        localStorage.setItem("ripple", enabled ? "on" : "off");
        if (!enabled) {
          if (state.rafId) cancelAnimationFrame(state.rafId);
          state.rafId = 0;
          ctx.clearRect(0, 0, state.width, state.height);
          return;
        }
        resize();
        if (!state.rafId) state.rafId = requestAnimationFrame(draw);
      };

      const observer = new IntersectionObserver(
        (entries) => {
          const visible = entries.some((entry) => entry.isIntersecting);
          if (!state.enabled) return;
          if (visible && !state.rafId) state.rafId = requestAnimationFrame(draw);
          if (!visible && state.rafId) {
            cancelAnimationFrame(state.rafId);
            state.rafId = 0;
          }
        },
        { threshold: 0.1 }
      );

      resize();
      observer.observe(mount);
      window.addEventListener("resize", resize, { passive: true });
      window.addEventListener("pointermove", onPointerMove, { passive: true });

      const stored = localStorage.getItem("ripple");
      applyEnabled(stored !== "off");
      if (rippleToggle) {
        rippleToggle.addEventListener("click", () => applyEnabled(!state.enabled));
      }
    })();
  </script>
</body>
</html>
